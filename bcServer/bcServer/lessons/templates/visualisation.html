<!DOCTYPE html>
<html>
<body>
function f(<input id="arguments" type="text" value="n=5"/>)<br>
<textarea id="input" cols="50" rows="20">
  if (n==0) return 0
  if (n==1) return 1
  return f(n-1)+f(n-2)
</textarea>
<input type="checkbox" id="memoIsOn">memorize<br>
<button onclick="ev()">evaluate</button><br>
<button onclick="nextStepClick()"> next step </button>
<button onclick="stepBack()"> previous step </button>
<button onclick="drawAll()"> draw all </button><br>
<button onclick="play()"> play </button>
<button onclick="stop()"> pause </button><br>
<canvas id="visualiser" width="1500" height="700" style="border:1px solid #000000;">no html5</canvas>
<script>
  const maxX = document.getElementById("visualiser").width
  const maxY = document.getElementById("visualiser").height
  var modFunction
  var originalFunction
  var f
  var code
  var arrayPairs
  var arguments
  var parameters
  var nodesList = []
  var edgesList = []
  var nodeStack = []
  var maxDepth = 0
  var currentNode = 0
  var drawnNodes = []
  var unresolvedNodes = []
  var stepStack = []
  var memory = {}
  var drawnMemory = []
  var firstOccurence = {}
  var memoIsOn
  var totalLeaves
  var overflow = false
  const visualiser = document.getElementById("visualiser")
  const context = visualiser.getContext("2d");
  var modFunction = function() {
    if (!overflow) {
      var newNode = {
        id: 0,
        x: 0,
        y: 0,
        parent: -1,
        args: Array.from(arguments),
        result: undefined,
        depth: 0,
        children:[],
        showResult: false,
        leavesCount: 0
      }
      newNode.id = nodesList.length
      if (nodeStack.length > 0) {
        newNode.parent = nodeStack[nodeStack.length-1]
        nodesList[nodeStack[nodeStack.length-1]].children.push(newNode.id)
      }
      newNode.depth = nodeStack.length
      if (newNode.depth > maxDepth) {
        maxDepth = newNode.depth
      }
      nodeStack.push(newNode.id)
      nodesList.push(newNode)
      if (nodesList.length>1000) {
        alert ("too many nodes")
        overflow = true
        clear()
        return -1
      } else {
        var returnValue = originalFunction.apply(this, arguments)
      newNode.result = returnValue
      if (newNode.children.length == 0) {
        newNode.leavesCount = 1
        } else {
        for(child in newNode.children) {
          newNode.leavesCount += nodesList[newNode.children[child]].leavesCount
        }
      }
      nodeStack.pop()
      return returnValue
    }
  }
}

var modFunctionMemo = function() {
  if (!overflow) {
    var newNode = {
      id: 0,
      x: 0,
      y: 0,
      parent: -1,
      args: Array.from(arguments),
      result: undefined,
      depth: 0,
      children:[],
      showResult: false,
      fromMemory: false,
      leavesCount: 0,
    }
    newNode.id = nodesList.length
    if (nodeStack.length > 0) {
      newNode.parent = nodeStack[nodeStack.length-1]
      nodesList[nodeStack[nodeStack.length-1]].children.push(newNode.id)
    }
    newNode.depth = nodeStack.length
    if (newNode.depth > maxDepth) {
      maxDepth = newNode.depth
    }
    nodesList.push(newNode)
    var returnValue
    if (memory[newNode.args.toString()] != null) {
      returnValue = memory[newNode.args.toString()]
      newNode.fromMemory = true
      newNode.leavesCount = 1
    } else {
      nodeStack.push(newNode.id)
      if (nodesList.length>1000) {
        alert ("too many nodes")
        overflow = true
        clear()
        return -1
      } else {
        returnValue = originalFunction.apply(this, arguments)
        memory[newNode.args.toString()] = returnValue
        firstOccurence[newNode.args.toString()] = newNode.id
      }
      nodeStack.pop()
      if (newNode.children.length == 0) {
        newNode.leavesCount = 1
        } else {
        for(child in newNode.children) {
          newNode.leavesCount += nodesList[newNode.children[child]].leavesCount
        }
      }
    }
    newNode.result = returnValue
    return returnValue
  }
}


  var calculateY = function() {
    for (node in nodesList) {
      var levelSize = maxY/(maxDepth+1)
      var current = nodesList[node]
      current.y = levelSize*current.depth+Math.round(levelSize/2)
    }
  }

  var calculateX = function(id, left, right) {
    var currentNode = nodesList[id]
  //  console.log(currentNode)
    var size = right-left
    var childNumber = currentNode.children.length
    var usedLeaves = 0
    currentNode.x = Math.round((left+right)/2)
    for (var i = 0; i < childNumber; i++) {
      var child = nodesList[currentNode.children[i]]
      calculateX (
          child.id,left + (size/currentNode.leavesCount)*usedLeaves, left + (size/currentNode.leavesCount)*(usedLeaves+child.leavesCount)
        )
      usedLeaves += child.leavesCount
    }
  }

  var saveOriginalFunction = function (head, body) {
    var fAsString = "function ("+head+") {"+code+"}"
    originalFunction = eval("_f = "+fAsString)
  }

  var makeTree = function () {
    if (memoIsOn) {
      f = modFunctionMemo
      modFunctionMemo.apply(this, arguments)
    } else {
      f = modFunction
      modFunction.apply(this, arguments)
    }

  }

function ev() {
  clear()
  memoIsOn = document.getElementById("memoIsOn").checked
  var argtext=document.getElementById("arguments").value
  arrayPairs = argtext.split(",")
  for (var i = 0; i<arrayPairs.length;i++) {
    arrayPairs[i] = arrayPairs[i].split("=")
  }
  arguments = ""
  for (var i = 0; i<arrayPairs.length;i++) {
    if(i!=0) arguments += ", "
    arguments += arrayPairs[i][0]
  }
  code = document.getElementById("input").value
  parametersString = ""
  parametersArray = []
  for (var i = 0; i<arrayPairs.length;i++) {
    if(i!=0) parametersString += ", "
    parametersString += arrayPairs[i][1]
    parametersArray.push(arrayPairs[i][1])
  }
  saveOriginalFunction(arguments, code)
  eval("makeTree("+parametersString+")")
  totalLeaves = nodesList[0].leavesCount
  calculateX(0,0,maxX)
  calculateY()
  unresolvedNodes.push(0)
  drawnNodes.push(0)
  redraw()
  play()
}

var drawCircle = function (x,y) {
  context.fillStyle="white"
  context.beginPath()
  context.arc(x,y,15,0,2*Math.PI)
  context.stroke()
  context.fill()
}
var drawArgs = function (id, x, y) {
  context.fillStyle="black"
  context.font = "15px Arial"
  context.textAlign="center"
  context.fillText(nodesList[id].args.toString(),x,y)
}

var checkIfResolved = function (id) {
  var children = nodesList[id].children
  nodesList[id].showResult=true
  for(child in children) {
  //  console.log(id+" "+children[child])
    if (nodesList[children[child]].showResult == false) {
      nodesList[id].showResult = false
    }
  }
  return nodesList[id].showResult
}

var drawResult = function (id, x, y) {
  context.fillStyle="green"
  context.font = "15px Arial"
  context.textAlign="center"
  //console.log(nodesList[id])
  if(nodesList[id].showResult)
    context.fillText(nodesList[id].result.toString(),x,y)
}
var drawNode = function(id) {
  var x = nodesList[id].x
  var y = nodesList[id].y
  context.beginPath()
  if(nodesList[id].parent != -1) {
    var parent = nodesList[nodesList[id].parent]
    context.moveTo(x,y)
    context.lineTo(parent.x,parent.y)
    context.stroke()
    drawCircle(parent.x,parent.y)
    drawArgs(parent.id,parent.x,parent.y)
    drawResult(parent.id,parent.x,parent.y+30)
  }
  drawCircle(x,y)
  drawArgs(id,x,y)
  drawResult(id,x,y+30)
  context.stroke()
}

var redraw = function() {
  context.clearRect(0, 0, maxX, maxY)
  if (nodesList[currentNode].fromMemory && stepStack[stepStack.length-1] == -1) {
    original = nodesList[firstOccurence[nodesList[currentNode].args.toString()]]
    context.setLineDash([5])
    context.beginPath()
    context.moveTo(nodesList[currentNode].x, nodesList[currentNode].y)
    context.lineTo(original.x, original.y)
    context.stroke()
    context.setLineDash([0])
    //console.log(nodesList[currentNode].x+" "+ nodesList[currentNode].y)
    console.log(firstOccurence[nodesList[currentNode].args.toString()])
}
  for (i in drawnNodes) {
    drawNode(i)
  }
  redrawMemory()
}

var nextStepClick = function() {
  stop()
  nextStep()
}

var redrawMemory = function() {
  context.textAlign = "left"
  context.fillStyle = "black"
  for (i in drawnMemory) {
    context.beginPath()
    context.fillText(drawnMemory[i],0,i*20+20)
    context.stroke()
  }
}

var nextStep = function() {
  if (unresolvedNodes.length==0) {
    return false
  }
  var lastUnresolved = nodesList[unresolvedNodes[unresolvedNodes.length-1]]
  checkIfResolved(lastUnresolved.id)
  if (lastUnresolved.showResult) {
    stepStack.push(lastUnresolved.id)
    unresolvedNodes.pop()
    if (memoIsOn) {
      if (!lastUnresolved.fromMemory) {
        drawnMemory.push("("+lastUnresolved.args.toString()+") = "+lastUnresolved.result)
        //console.log(drawnMemory)
      }
    }
  } else {
    stepStack.push(-1)
    currentNode++
    drawnNodes.push(nodesList[currentNode])
    if (memoIsOn) {
      if (!nodesList[currentNode].fromMemory && nodesList[currentNode].children.length == 0) {
        drawnMemory.push("("+nodesList[currentNode].args.toString()+") = "+nodesList[currentNode].result)
        //console.log(drawnMemory)
      }
    }
    if(!checkIfResolved(currentNode)) {
      unresolvedNodes.push(currentNode)
    }
  }
  redraw()
  return true
}

var drawAll = function () {
  while (nextStep()) {}
}

var stepBack = function() {
  stop()
  if(stepStack.length == 0) {
    return
  }
  var step = stepStack[stepStack.length-1]
  if (step >= 0) {
    unresolvedNodes.push(step)
    nodesList[step].showResult = false
    if (!nodesList[step].fromMemory) {
      drawnMemory.pop()
    }
  } else {
    if(unresolvedNodes[unresolvedNodes.length-1] == currentNode){
      unresolvedNodes.pop()
    }
    if (!nodesList[currentNode].fromMemory) {
      drawnMemory.pop()
    }
    nodesList[currentNode].showResult = false
    currentNode--
    drawnNodes.pop()
  }
stepStack.pop()
redraw()
}

var interval

var play = function() {
  interval = setInterval(nextStep,1000)
}

var stop = function() {
  clearInterval(interval)
}
function clear() {
  nodesList = []
  edgesList = []
  nodeStack = []
  drawnNodes = []
  unresolvedNodes = []
  maxDepth = 0
  currentNode = 0
  memory = {}
  firstOccurence = {}
  drawnMemory = []
  context.clearRect(0, 0, maxX, maxY)
  stop()
}
</script>



</body>
</html>
