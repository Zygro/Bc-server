<!DOCTYPE html>
<html>
<body>
function f(<input id="arguments" type="text" />)<br>
<textarea id="input" cols="50" rows="20"></textarea>
<button onclick="ev()">evaluate</button><br>
<button onclick="nextStep()"> next step </button>
<button onclick="stepBack()"> previous step </button><br>
<canvas id="visualiser" width="1500" height="700" style="border:1px solid #000000;">no html5</canvas>
<script>
  const maxX = document.getElementById("visualiser").width
  const maxY = document.getElementById("visualiser").height
  var modFunction
  var originalFunction
  var f
  var code
  var arrayPairs
  var arguments
  var parameters
  var nodesList = []
  var edgesList = []
  var nodeStack = []
  var maxDepth = 0
  var currentNode = 0
  var drawnNodes = []
  var unresolvedNodes = []
  var stepStack = []
  const visualiser = document.getElementById("visualiser")
  const context = visualiser.getContext("2d");
  var modFunction = function() {
    var newNode = {
      id: 0,
      x: 0,
      y: 0,
      parent: -1,
      args: Array.from(arguments),
      result: undefined,
      depth: 0,
      children:[],
      showResult: false,
    }
    newNode.id = nodesList.length
    if (nodeStack.length > 0) {
      newNode.parent = nodeStack[nodeStack.length-1]
      nodesList[nodeStack[nodeStack.length-1]].children.push(newNode.id)
    }
    newNode.depth = nodeStack.length
    if (newNode.depth > maxDepth) {
      maxDepth = newNode.depth
    }
    nodeStack.push(newNode.id)
    nodesList.push(newNode)
    var returnValue = originalFunction.apply(this, arguments)
    newNode.result = returnValue
    nodeStack.pop()
    return returnValue
  }

  var calculateY = function() {
    for (node in nodesList) {
      var levelSize = maxY/(maxDepth+1)
      var current = nodesList[node]
      current.y = levelSize*current.depth+Math.round(levelSize/2)
    }
  }

  var calculateX = function(id, left, right) {
    var currentNode = nodesList[id]
    var size = right-left
    var childNumber = currentNode.children.length
    currentNode.x = Math.round((left+right)/2)
    for (var i = 0; i < childNumber; i++) {
      calculateX (currentNode.children[i], left + (size/childNumber)*i, left + (size/childNumber)*(i+1))
    }
  }

  var saveOriginalFunction = function (head, body) {
    var fAsString = "function ("+head+") {"+code+"}"
    originalFunction = eval("_f = "+fAsString)
  }

  var makeTree = function () {
    f = modFunction
    modFunction.apply(this, arguments)
  }

function ev() {
  clear()
  var argtext=document.getElementById("arguments").value
  arrayPairs = argtext.split(",")
  for (var i = 0; i<arrayPairs.length;i++) {
    arrayPairs[i] = arrayPairs[i].split("=")
  }
  arguments = ""
  for (var i = 0; i<arrayPairs.length;i++) {
    if(i!=0) arguments += ", "
    arguments += arrayPairs[i][0]
  }
  code = document.getElementById("input").value
  parametersString = ""
  parametersArray = []
  for (var i = 0; i<arrayPairs.length;i++) {
    if(i!=0) parametersString += ", "
    parametersString += arrayPairs[i][1]
    parametersArray.push(arrayPairs[i][1])
  }
  saveOriginalFunction(arguments, code)
  eval("makeTree("+parametersString+")")
  calculateX(0,0,maxX)
  calculateY()
  unresolvedNodes.push(0)
  drawnNodes.push(0)
  redraw()
}

var drawCircle = function (x,y) {
  context.fillStyle="white"
  context.beginPath()
  context.arc(x,y,15,0,2*Math.PI)
  context.stroke()
  context.fill()
}
var drawArgs = function (id, x, y) {
  context.fillStyle="black"
  context.font = "15px Arial"
  context.textAlign="center"
  context.fillText(nodesList[id].args.toString(),x,y)
}

var checkIfResolved = function (id) {
  var children = nodesList[id].children
  nodesList[id].showResult=true
  for(child in children) {
  //  console.log(id+" "+children[child])
    if (nodesList[children[child]].showResult == false) {
      nodesList[id].showResult = false
    }
  }
  return nodesList[id].showResult
}

var drawResult = function (id, x, y) {
  context.fillStyle="green"
  context.font = "15px Arial"
  context.textAlign="center"
  //console.log(nodesList[id])
  if(nodesList[id].showResult)
    context.fillText(nodesList[id].result.toString(),x,y)
}
var drawNode = function(id) {
  var x = nodesList[id].x
  var y = nodesList[id].y
  context.beginPath()
  if(nodesList[id].parent != -1) {
    var parent = nodesList[nodesList[id].parent]
    context.moveTo(x,y)
    context.lineTo(parent.x,parent.y)
    context.stroke()
    drawCircle(parent.x,parent.y)
    drawArgs(parent.id,parent.x,parent.y)
    drawResult(parent.id,parent.x,parent.y+30)
  }
  drawCircle(x,y)
  drawArgs(id,x,y)
  drawResult(id,x,y+30)
  context.stroke()
}

var redraw = function() {
context.clearRect(0, 0, maxX, maxY)
  for (i in drawnNodes) {
    drawNode(i)
  }
}

var nextStep = function() {
  if (unresolvedNodes.length==0) {
    return
  }
  var lastUnresolved = nodesList[unresolvedNodes[unresolvedNodes.length-1]]
  checkIfResolved(lastUnresolved.id)
  if (lastUnresolved.showResult) {
    stepStack.push(lastUnresolved.id)
    unresolvedNodes.pop()
  } else {
    stepStack.push(-1)
    currentNode++
    drawnNodes.push(nodesList[currentNode])
    if(!checkIfResolved(currentNode)) {
      unresolvedNodes.push(currentNode)
    }
  }
  redraw()
}

var stepBack = function() {
  if(stepStack.length == 0) {
    return
  }
  var step = stepStack[stepStack.length-1]
  if (step >= 0) {
    unresolvedNodes.push(step)
    nodesList[step].showResult = false
  } else {
    if(unresolvedNodes[unresolvedNodes.length-1] == currentNode){
      unresolvedNodes.pop()
    }
    nodesList[currentNode].showResult = false
    currentNode--
    drawnNodes.pop()
  }
stepStack.pop()
redraw()
}
function clear() {
  nodesList = []
  edgesList = []
  nodeStack = []
  drawnNodes = []
  unresolvedNodes = []
  maxDepth = 0
  currentNode = 0
  context.clearRect(0, 0, maxX, maxY)
}
</script>

</body>
</html>
